// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
/// @title Advanced Auction Contract
/// @notice This contract allows the creation and management of an English auction.
///         It includes functionalities such as time extension, partial refunds, and fee management.
contract AuctionM2 {
    // ====================================================================================================
    //                                         STATE VARIABLES
    // ====================================================================================================
    address public immutable owner;         // Owner of the contract and the one who starts the auction.
    uint public auctionStartTime;           // Timestamp when the auction should start.
    uint public auctionEndTime;             // Timestamp when the auction should end.
    address public highestBidder;           // Address of the bidder with the highest bid.
    uint public highestBid;                 // Value of the highest bid.
    bool public auctionEnded;               // Indicator of whether the auction has ended.
    uint private accumulatedFees;           // Total accumulated fees.
    uint public winningBid;                 // Stores the final winning bid for lookup.
    // mapping: bidder address => amount of Ether deposited and pending return.
    // Includes the current bid amount and any partially withdrawn excess.
    mapping(address => uint) public pendingReturns;
    // mapping: bidder address => last valid bid placed by that bidder.
    mapping(address => uint) public latestBid;
    // To know if an address has already been added to _activeBidders, to avoid duplicates
    mapping(address => bool) private _isBidderActive;
    // List of active bidder addresses for iteration (WARNING: Gas-costly for large datasets)
    address[] private _activeBidders;
    // Constant for the gas fee (2% = 200 out of 10000 parts)
    uint private constant FEE_PERCENTAGE = 200; // 2% = 200 / 10000
    // Constant for auction time extension (10 minutes in seconds)
    uint private constant AUCTION_EXTENSION_TIME = 10 minutes; // 10 minutes * 60 seconds/minute
    // Constant for the minimum bid increment (5% = 500 out of 10000 parts)
    uint private constant MIN_BID_INCREMENT_PERCENTAGE = 500; // 5% = 500 / 10000
    // ====================================================================================================
    //                                          EVENTS
    // ====================================================================================================
    ///@dev Emitted when the auction starts.
    ///@param owner owner's address
    //@param _auctionStartTime auction start time
    //@param _auctionEndTime auction end time
    event AuctionStarted(address indexed owner, uint _auctionStartTime, uint _auctionEndTime);

    /// @dev Emitted when a new valid bid is placed.
    /// @param bidder The bidder's address.
    /// @param amount The bid amount.
    /// @param _currentTime current auction time.
    event NewBid(address indexed bidder, uint amount, uint _currentTime);
    
    ///@dev Emitted when the auction is extended.
    ///@param _highestBidder highest bidder's address
    ///@param _currentTime current auction time
    ///@param _auctionEndTime auction end time
    event AuctionExtension(address indexed _highestBidder, uint _currentTime, uint _auctionEndTime);

    /// @dev Emitted when the auction has ended.
    /// @param _winner The winning bidder's address.
    /// @param _winningBid The winning bid amount.
    event AuctionEnded(address indexed _winner, uint _winningBid);

    /// @dev Emitted when a participant withdraws funds (partial or final refund).
    /// @param withdrawer The address withdrawing funds.
    /// @param amount The amount of funds withdrawn.
    event FundsWithdrawn(address indexed withdrawer, uint amount);

    /// @dev Emitted when owner withdraws funds and the auction has ended.
    /// @param owner The address withdrawing funds.
    /// @param amount The amount of funds withdrawn.
    event OwnerWithdrawn(address indexed owner, uint amount);

    /// @dev Emitted when the auction ended with no bids.
    /// @param _auctionStartTime auction start time.
    /// @param _auctionEndTime auction end time.
    event NoOffers (address indexed _owner, uint _auctionStartTime, uint _auctionEndTime);

    // ====================================================================================================
    //                                           MODIFIERS
    // ====================================================================================================
    /// @dev Restricts access to the function only to the contract owner.
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function.");
        _;
    }
    /// @dev Restricts function execution if the auction has already ended.
    modifier notEnded() {
        require(!auctionEnded, "The auction has already ended.");
        _;
    }
    /// @dev Restricts function execution until the auction has ended.
    modifier onlyAfterEnd() {
        require(block.timestamp >= auctionEndTime, "The auction has not ended yet.");
        _;
    }
    /// @dev Restricts function execution if the auction has not started.
    modifier auctionStarted() {
        require(auctionEndTime != 0, "The auction has not been initialized.");
        _;
    }
    // ====================================================================================================
    //                                             CONSTRUCTOR
    // ====================================================================================================
    /// @dev The constructor executes only once when the contract is deployed.
    ///      It initializes the contract owner and the auction duration.
    /// @param _biddingTime The duration of the auction in seconds from the deployment time.
    constructor(uint _biddingTime) {
        owner = msg.sender;
        // The auction ends at deployment time + bidding time.
        // block.timestamp is used for the current time on the blockchain.
        auctionEndTime = block.timestamp + _biddingTime;
        auctionStartTime = block.timestamp;
        emit AuctionStarted(owner, auctionStartTime, auctionEndTime);
    }
    // ====================================================================================================
    //                                            MAIN FUNCTIONS
    // ====================================================================================================
    /// @dev Allows participants to bid on the item.
    ///      For a bid to be valid, it must be greater than the current highest bid by at least 5%
    ///      and must be placed while the auction is active.
    function bid() external payable notEnded auctionStarted {
        // Validation 0: The contract owner cannot place bids.
        require(msg.sender != owner, "Owner cannot bid in their own auction.");
        // Validation 1: Ensure the auction is still active by time.
        require(block.timestamp < auctionEndTime, "The auction has ended by time."); 
        // Validation 2: Ensure the amount sent is greater than 0.
        require(msg.value > 0, "Bid must be greater than 0.");
        // Validation 3: Calculate the minimum required increment (5% of the highest bid).
        uint minBidIncrement = (highestBid * MIN_BID_INCREMENT_PERCENTAGE) / 10000;
        // The new bid must be at least 5% higher than the current highest bid.
        require(msg.value > (highestBid + minBidIncrement), "Bid must be at least 5% higher than the current highest bid.");
        
        // If there is a previous bidder, their current bid is moved to pendingReturns so it can be claimed.
        // This is crucial for partial/final refund functionality.
        if (highestBidder != address(0)) {
            pendingReturns[highestBidder] += highestBid;
        }
        
        // Update the highest bid and the highest bidder.
        highestBidder = msg.sender;
        highestBid = msg.value;
        
        // Record the latest valid bid of msg.sender.
        latestBid[msg.sender] = msg.value;
        
        // Logic to register the bidder if it's their first time bidding.
        if (!_isBidderActive[msg.sender]) {
            _activeBidders.push(msg.sender);
            _isBidderActive[msg.sender] = true;
        }
        // Handle auction time extension.
        // If current time + 10 minutes is greater than the current auction end time,
        // and the auction has not yet ended by time (it's in the last 10 minutes of its original duration).
        // The second condition is to ensure extension only happens near the end,
        // not at any point during the auction.
        if (block.timestamp < auctionEndTime && (auctionEndTime - block.timestamp) < AUCTION_EXTENSION_TIME) {
            auctionEndTime += AUCTION_EXTENSION_TIME;
            emit AuctionExtension(highestBidder, block.timestamp, auctionEndTime);
        }
        // Emit an event to notify that a new bid has been placed.
        emit NewBid (highestBidder, highestBid, block.timestamp);
    }
    
    ///@dev Shows the winning bidder and the winning bid amount.
    ///     Can only be called once the auction has ended.
    ///@return address The address of the winning bidder.
    ///@return uint The amount of the winning bid.
    function showWinner() external onlyAfterEnd returns (address, uint) {
        if (highestBidder == address(0)) {
            // Mark the auction as ended.
            auctionEnded = true;
            // Emit the auction ended event.
            emit AuctionEnded(highestBidder, winningBid);
            return (address(0), 0);
        }
        return (highestBidder, winningBid);
    }
    ///@dev Allows ending the auction once the time has expired.
    ///     Only the owner can call this function, and only if the time has passed.  
    function endAuction() external onlyOwner notEnded { 
        // Can only be ended if the time has expired.
        require(block.timestamp >= auctionEndTime, "The auction has not ended by time.");
        if (highestBidder == address(0)) {
            emit NoOffers(owner, auctionStartTime, auctionEndTime); 
            }
        // Mark the auction as ended.
        auctionEnded = true;
        // Stores the final winning bid.
        // To retain the information even after contract funds have been withdrawn.
        winningBid = highestBid; 
        // Emit the auction ended event.
        emit AuctionEnded(highestBidder, winningBid);
    }
    /// @dev Shows a list of bidders who have funds in the contract
    ///      and their respective last valid bids.
    /// @return biddersList An array of bidder addresses.
    /// @return bidsAmounts An array of the amounts of the last valid bids corresponding to each bidder.
    function showBids() external view returns (address[] memory biddersList, uint[] memory bidsAmounts) {
        uint numBidders = _activeBidders.length;
        // Create in-memory arrays for the results.
        biddersList = new address[](numBidders);
        bidsAmounts = new uint[](numBidders);
        // Iterate over the array of addresses to get their latest bids.
        for (uint i = 0; i < numBidders; i++) {
            address bidderAddress = _activeBidders[i];
            biddersList[i] = bidderAddress;
            bidsAmounts[i] = latestBid[bidderAddress];
        }
        return (biddersList, bidsAmounts);
    }
    /// @dev Allows participants to withdraw the amount from their deposit that exceeds their last bid
    ///      during the auction.
    function partialRefund() external notEnded auctionStarted {
        // Ensure the sender has excess funds deposited beyond their last bid.
        require(pendingReturns[msg.sender] > 0, "No excess funds to withdraw.");
        uint amountToWithdraw = pendingReturns[msg.sender];
        // Reset the pending balance before transfer (Checks-Effects-Interactions).
        pendingReturns[msg.sender] = 0; 
        // Calculate the 2% fee.
        uint fee = (amountToWithdraw * FEE_PERCENTAGE) / 10000;
        uint amountAfterFee = amountToWithdraw - fee;
        // Accumulate the fee (Same as in withdrawDeposits)
        accumulatedFees += fee;
        // Attempt to send Ether to the user.
        (bool success, ) = payable(msg.sender).call{value: amountAfterFee}("");
        require(success, "Failed to withdraw funds.");
        // Emit when a participant withdraws funds (partial or final refund).
        emit FundsWithdrawn(msg.sender, amountAfterFee);
    }

    /// @dev Upon auction end, deposits are returned to non-winning bidders,
    ///      minus a 2% fee for gas.
    ///      This function can be called by anyone once the auction has ended.
    function withdrawDeposits() external onlyAfterEnd {
        // Ensure the sender has pending funds.
        require(pendingReturns[msg.sender] > 0, "You have no pending funds to withdraw.");
        // Mark the auction as ended.
        auctionEnded = true;
        // Emit the auction ended event.
        emit AuctionEnded(highestBidder, winningBid);

        uint amountToWithdraw = pendingReturns[msg.sender];
        pendingReturns[msg.sender] = 0; // Reset the pending balance before transfer (Checks-Effects-Interactions).
        // Calculate the 2% fee.
        uint fee = (amountToWithdraw * FEE_PERCENTAGE) / 10000;
        uint amountAfterFee = amountToWithdraw - fee;
        // Accumulate the fee
        accumulatedFees += fee;
        // Attempt to send Ether to the user.
        (bool success, ) = payable(msg.sender).call{value: amountAfterFee}("");
        require(success, "Failed to withdraw funds.");
        // The fee remains in the contract for the owner to withdraw later.
        emit FundsWithdrawn(msg.sender, amountAfterFee);
    }
    /// @dev Allows the contract owner to withdraw auction funds (winning bid and fees).
    ///      Can only be called by the owner and once the auction has ended.
    ///      Also handles the scenario where there were no valid bids.
    function ownerWithdraw() external onlyOwner onlyAfterEnd {
        // Mark the auction as ended.
        auctionEnded = true;
        // Emit the auction ended event.
        emit AuctionEnded(highestBidder, winningBid);
        uint totalAmountToWithdraw = 0;
        // 1. Withdraw the winning bid (if there was a winner and it hasn't been withdrawn yet)
        if (highestBidder != address(0) && highestBid > 0) {
            totalAmountToWithdraw += highestBid;
            highestBid = 0; // Mark the winning bid as withdrawn to prevent double withdrawals.
        }
        // 2. Withdraw accumulated fees
        if (accumulatedFees > 0) {
            totalAmountToWithdraw += accumulatedFees;
            accumulatedFees = 0; // Mark fees as withdrawn.
        }
        require(totalAmountToWithdraw > 0, "No auction funds or fees to withdraw.");
        // Attempt to send Ether to the owner.
        (bool success, ) = payable(owner).call{value: totalAmountToWithdraw}("");
        require(success, "Failed to withdraw funds for owner.");

        //Emit when owner withdraws funds and the auction has ended.
        emit OwnerWithdrawn(owner, totalAmountToWithdraw);
    }
}
